<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bonança Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bonança Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bonança"><a class="header" href="#bonança">Bonança</a></h1>
<p>Bonança (pronounced boh-nahn-sah) is an open-source library for
creating crypto defi bots on various blockchains. It provides functionalities
for creating HD wallets, private key encryption, executing trades, lending
and borrow crypto, and more.</p>
<p>Bonança is fully free and completely open source. You can find the source code on <a href="https://github.com/Cavenfish/bonanca">GitHub</a>. The crypto is yours, and you are in full control of your funds at all times.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>Create and manage wallets using secure <code>KeyVaults</code>.</li>
<li>Connect to multiple blockchains (e.g., Solana, EVM-compatible chains).</li>
<li>Integrate with various exchanges and oracles for trading and price data.</li>
<li>Python wrapper</li>
</ul>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>This documentation has been largely written by AI, so it is likely there are
some inaccuracies in the code examples. I occasionally look over the docs to
fix them, but some might still be out there.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>To get started with Bonança, follow the instructions in the <a href="./install.html">Installation</a> guide. Once installed, you can create a wallet by following the steps in the <a href="./create.html">Create Account</a> section. After setting up your wallet, you can manage your index fund using the instructions provided in the <a href="./manage_index.html">Manage Index Fund</a> documentation.</p>
<h2 id="about-the-name"><a class="header" href="#about-the-name">About The Name</a></h2>
<p>Bonança is a Portuguese word used to describe a period of prosperity and tranquility, that typically comes after a period of instability or hardship. In the context of this project, Bonança represents a tool that aims to bring financial stability and growth to cryptocurrency investors.</p>
<p>A big insipration for the name comes from a verse in a famous Brazilian funk song "Rap da Felicidade" by Cidinho and Doca:</p>
<blockquote>
<p>"Sofri na tempestade, agora eu quero a bonança"</p>
</blockquote>
<p>Which translates to "I suffered in the storm, now I want prosperity". I hope this CLI can help users find their own "bonança" in the volatile world of cryptocurrency investing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<pre><code class="language-bash">cargo add bonanca
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallets"><a class="header" href="#wallets">Wallets</a></h1>
<p>This section documents the wallet and key management utilities provided by Bonanca. It covers creating and managing EVM and Solana wallets, using the keyvault, signing transactions, and helper functions for balance and token operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hd-wallets"><a class="header" href="#hd-wallets">HD Wallets</a></h1>
<p>Bonança can create a master key for a Hierarchical Deterministic (HD)
wallet, which can generate multiple child keys for different blockchains.
This means you can manage multiple wallets for multiple blockchains (e.g.,
Solana, EVM-compatible chains) using a single <code>KeyVault</code> file. If you are
unfamiliar with HD wallets consider reading <a href="https://learnmeabitcoin.com/technical/keys/hd-wallets/">this post</a>.</p>
<h2 id="creating-a-new-hd-wallet"><a class="header" href="#creating-a-new-hd-wallet">Creating a New HD Wallet</a></h2>
<p>HD wallets are stored as <code>KeyVault</code> files in Bonança, which is explained
in more depth <a href="wallets/keyvault.html">here</a>. You can create a <code>KeyVault</code> using Rust
or Python.</p>
<h4 id="rust"><a class="header" href="#rust">Rust</a></h4>
<pre><code class="language-rust ignore">use bonanca::keyvault::KeyVault;
use std::path::Path;

fn main() {
  // Create new KeyVault with english mneomonic
  let key_vault = KeyVault::new("English");
  let filename = Path::new("./keyvault.json");

  // Write json file
  key_vault.write(filename)
}</code></pre>
<h4 id="python"><a class="header" href="#python">Python</a></h4>
<pre><code class="language-python">from bonanca import KeyVault

# Create new KeyVault with english mneomonic
key_vault = KeyVault.new("English")

# Write json file
key_vault.write("./keyvault.json")
</code></pre>
<p>The available languages for the mneomonic are:</p>
<ul>
<li>English</li>
<li>Simplified Chinese</li>
<li>Traditional Chinese,</li>
<li>French</li>
<li>Italian</li>
<li>Japanese</li>
<li>Korean</li>
<li>Spanish</li>
</ul>
<h2 id="create-a-keyvault-from-a-mneomonic"><a class="header" href="#create-a-keyvault-from-a-mneomonic">Create a KeyVault from a Mneomonic</a></h2>
<p>You can also create a <code>KeyVault</code> from an existing mneomonic phrase. This is useful if you already have a wallet and want to manage it using Bonança.</p>
<h4 id="rust-1"><a class="header" href="#rust-1">Rust</a></h4>
<pre><code class="language-rust ignore">use bonanca::keyvault::KeyVault;

fn main() {
  // Your mneomonic (in any language listed above)
  let mneomonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";

  let key_vault = KeyVault::from_mneomonic(mneomonic);
  let filename = Path::new("./keyvault.json");

  // Write json file
  key_vault.write(filename)
}</code></pre>
<h4 id="python-1"><a class="header" href="#python-1">Python</a></h4>
<pre><code class="language-python">from bonanca import KeyVault

# Your mneomonic (in any language listed above)
mneomonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about

key_vault = KeyVault.from_mneomonic(mneomonic)

# Write json file
key_vault.write("./keyvault.json")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view-vs-load"><a class="header" href="#view-vs-load">View vs Load</a></h1>
<p>Bonança offers you the ability to interact with wallets in two modes; <code>view</code> and
<code>load</code>. In <code>view</code> mode the wallet is only the public key, whereas, <code>load</code> has
both public and private keys. This is useful for when you want to check token
balances without having to expose your private key or type your password in.</p>
<h3 id="rust-2"><a class="header" href="#rust-2">Rust</a></h3>
<p>In Rust <code>view</code> and <code>load</code> are both methods of the wallet struct.</p>
<pre><code class="language-rust ignore">use bonanca::wallets::{EvmWallet, SolWallet}
use std::path::Path;

fn main() {
    let filename = Path::new("./keyvault.json");
    let child = 0;

    let evm_wallet_view = EvmWallet::view(filename, "rpc_url", child)
    let sol_wallet_view = SolWallet::view(filename, "rpc_url", child)

    let evm_wallet_load = EvmWallet::load(filename, "rpc_url", child)
    let sol_wallet_load = SolWallet::load(filename, "rpc_url", child)
}</code></pre>
<h3 id="python-2"><a class="header" href="#python-2">Python</a></h3>
<p>In Python the dynamic style <code>view</code> and <code>load</code> isn't possible, so instead there
are two different classes for each method.</p>
<pre><code class="language-python">import bonanca

wallet_view = bonanca.wallets.EvmWalletView("keyvault.json", "rpc_url", 0)

wallet_load = bonanca.wallets.EvmWallet("keyvault.json", "rpc_url", 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evm-wallet"><a class="header" href="#evm-wallet">EVM Wallet</a></h1>
<p>To interact with an EVM-compatible wallet using <code>bonanca</code> you can use
the <code>EvmWallet</code> struct.</p>
<h2 id="parse-and-format-decimals"><a class="header" href="#parse-and-format-decimals">Parse and Format Decimals</a></h2>
<p>You can use the <code>parse_decimals</code> and <code>format_decimals</code> methods to convert between
the raw integer representation of token amounts and the human-readable decimal format.</p>
<h4 id="rust-3"><a class="header" href="#rust-3">Rust</a></h4>
<pre><code class="language-rust ignore">// Format a float into a big int
let big_amount = wallet.format_native(2.5); // Native (ETH, POL, ...) only
let big_amount_token = wallet.format_token(14.2, "TOKEN_ADDRESS"); // Any token

// Parse a big int number into a float
let x0 = wallet.parse_native(big_amount); // Native (ETH, POL, ...) only
let x1 = wallet.parse_token(big_amount_token, "TOKEN_ADDRESS"); // Any token</code></pre>
<h4 id="python-3"><a class="header" href="#python-3">Python</a></h4>
<pre><code class="language-python"># Format a float into a big int
big_amount = wallet.format_native(2.5)# Native (ETH, POL, ...) only
big_amount_token = wallet.format_token(14.2, "TOKEN_ADDRESS")# Any token

# Parse a big int number into a float
x0 = wallet.parse_native(big_amount)# Native (ETH, POL, ...) only
x1 = wallet.parse_token(big_amount_token, "TOKEN_ADDRESS")# Any token
</code></pre>
<h2 id="balances"><a class="header" href="#balances">Balances</a></h2>
<p>Bonança provides methods to check native and token balances in your wallet. You can use the <code>balance</code> method to retrieve the native balance and the <code>token_balance</code> method for tokens.</p>
<h4 id="rust-4"><a class="header" href="#rust-4">Rust</a></h4>
<pre><code class="language-rust ignore">// Get native balance (as float)
let nat_bal = wallet.balance().await?;

// Get token balance (as float)
let tkn_bal = wallet.token_balance("TOKEN_ADDRESS").await?;</code></pre>
<h4 id="python-4"><a class="header" href="#python-4">Python</a></h4>
<pre><code class="language-python">sol_bal = wallet.balance()
spl_bal = wallet.token_balance("TOKEN_ADDRESS")
</code></pre>
<h2 id="token-approvals"><a class="header" href="#token-approvals">Token Approvals</a></h2>
<p>To approve an address for spending your tokens you can use the
<code>approve_token_spending</code> method.</p>
<h4 id="rust-5"><a class="header" href="#rust-5">Rust</a></h4>
<pre><code class="language-rust ignore">// Approve 2.05 tokens to be spent by spender address
wallet.approve_token_spending("TOKEN_ADDRESS","SPENDER_ADDRESS", 2.05).await?;</code></pre>
<h4 id="python-5"><a class="header" href="#python-5">Python</a></h4>
<pre><code class="language-python">wallet.approve_token_spending("TOKEN_ADDRESS","SPENDER_ADDRESS", 2.05)
</code></pre>
<h2 id="transfers"><a class="header" href="#transfers">Transfers</a></h2>
<p>For native transfers you can use the <code>transfer</code> method, and <code>token_transfer</code> for
tokens. For native transfers, specify the recipient's public key and the amount
as a decimal value. For token transfers, specify the recipient's token
account, the token address, and the amount in decimal value.</p>
<h4 id="rust-6"><a class="header" href="#rust-6">Rust</a></h4>
<pre><code class="language-rust ignore">// Transfer 2.5 native
let receipt = wallet.transfer(2.5, "TO_ADDRESS").await?;

// Transfer 2.5 token
let receipt2 = wallet.token_transfer("TOKEN_ADDRESS", 2.5, "TO_ADDRESS").await?;</code></pre>
<h4 id="python-6"><a class="header" href="#python-6">Python</a></h4>
<pre><code class="language-python"># Transfer 2.5 native
receipt = wallet.transfer(2.5, "TO_ADDRESS")

# Transfer 2.5 token
receipt2 = wallet.token_transfer("TOKEN_ADDRESS", 2.5, "TO_ADDRESS")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solana-wallet"><a class="header" href="#solana-wallet">Solana Wallet</a></h1>
<p>To interact with a Solana wallet using Bonança you can use the <code>SolWallet</code>
struct. For all examples shown below its assumed a wallet has been initialized
as <code>wallet</code>. In the examples where signing is not required a <code>view</code> wallet is
sufficient.</p>
<h2 id="parse-and-format-decimals-1"><a class="header" href="#parse-and-format-decimals-1">Parse and Format Decimals</a></h2>
<p>You can use the <code>parse_decimals</code> and <code>format_decimals</code> methods to convert between
the raw integer representation of token amounts and the human-readable decimal format.</p>
<h4 id="rust-7"><a class="header" href="#rust-7">Rust</a></h4>
<pre><code class="language-rust ignore">// Format a float into a big int
let big_amount = wallet.format_native(2.5); // Sol only
let big_amount_token = wallet.format_token(14.2, "TOKEN_MINT"); // Any SPL token

// Parse a big int number into a float
let x0 = wallet.parse_native(big_amount); // Sol only
let x1 = wallet.parse_token(big_amount_token, "TOKEN_MINT"); // Any SPL token</code></pre>
<pre><code class="language-python"># Format a float into a big int
big_amount = wallet.format_native(2.5) # Sol only
big_amount_token = wallet.format_token(14.2, "TOKEN_MINT") # Any SPL token

# Parse a big int number into a float
x0 = wallet.parse_native(big_amount)# Sol only
x1 = wallet.parse_token(big_amount_token, "TOKEN_MINT")# Any SPL token
</code></pre>
<h2 id="balances-1"><a class="header" href="#balances-1">Balances</a></h2>
<p>Bonança provides methods to check the balance of SOL and SPL tokens in your wallet. You can use the <code>balance</code> method to retrieve the balance of SOL and the <code>token_balance</code> method for SPL tokens.</p>
<h4 id="rust-8"><a class="header" href="#rust-8">Rust</a></h4>
<pre><code class="language-rust ignore">// Get Sol balance (as float)
let sol_bal = wallet.balance().await?;

// Get SPL token balance (as float)
let spl_bal = wallet.token_balance("TOKEN_MINT").await?;</code></pre>
<h4 id="python-7"><a class="header" href="#python-7">Python</a></h4>
<pre><code class="language-python">sol_bal = wallet.balance()
spl_bal = wallet.token_balance("TOKEN_MINT")
</code></pre>
<h2 id="create-token-account"><a class="header" href="#create-token-account">Create Token Account</a></h2>
<p>Before you can hold or transfer SPL tokens, you need to create a token account for the specific token mint. You can use the <code>create_token_account</code> method to create a new token account.</p>
<h4 id="rust-9"><a class="header" href="#rust-9">Rust</a></h4>
<pre><code class="language-rust ignore">let ata_pubkey = wallet.create_token_account("TOKEN_MINT").await?;</code></pre>
<h4 id="python-8"><a class="header" href="#python-8">Python</a></h4>
<pre><code class="language-python">ata_pubkey = wallet.create_token_account("TOKEN_MINT")
</code></pre>
<h2 id="burn-token"><a class="header" href="#burn-token">Burn Token</a></h2>
<p>To burn SPL tokens, you can use the <code>burn_token</code> method. This will permanently remove the specified amount of tokens from circulation. Note that unlike EVM
chains in Solana you can't burn tokens by sending them to burn address.</p>
<h4 id="rust-10"><a class="header" href="#rust-10">Rust</a></h4>
<pre><code class="language-rust ignore">let receipt = wallet.burn_token("TOKEN_MINT", 2.5).await?;</code></pre>
<h4 id="python-9"><a class="header" href="#python-9">Python</a></h4>
<pre><code class="language-python">receipt = wallet.burn_token("TOKEN_MINT", 2.5)
</code></pre>
<h2 id="close-token-account"><a class="header" href="#close-token-account">Close Token Account</a></h2>
<p>To close a token account, you can use the <code>close_token_account</code> method. This
can only be done when the token balance is zero (you must send or burn all
tokens before calling this method). After closing the account the SOL deposit
for the account will be returned to your wallet.</p>
<h4 id="rust-11"><a class="header" href="#rust-11">Rust</a></h4>
<pre><code class="language-rust ignore">wallet.close_token_account("TOKEN_MINT").await?;</code></pre>
<h4 id="python-10"><a class="header" href="#python-10">Python</a></h4>
<pre><code class="language-python">wallet.close_token_account("TOKEN_MINT")
</code></pre>
<h2 id="transfers-1"><a class="header" href="#transfers-1">Transfers</a></h2>
<p>To transfer SOL you can use the <code>transfer</code> method, and <code>token_transfer</code> for SPL
tokens. For SOL transfers, specify the recipient's public key and the amount
as a decimal value. For SPL token transfers, specify the recipient's token
account, the token mint, and the amount in decimal value.</p>
<h4 id="rust-12"><a class="header" href="#rust-12">Rust</a></h4>
<pre><code class="language-rust ignore">// Transfer 2.5 Sol
let receipt = wallet.transfer(2.5, "TO_ADDRESS").await?;

// Transfer 2.5 SPL token
let receipt2 = wallet.token_transfer("TOKEN_MINT", 2.5, "TO_ADDRESS").await?;</code></pre>
<h4 id="python-11"><a class="header" href="#python-11">Python</a></h4>
<pre><code class="language-python"># Transfer 2.5 Sol
receipt = wallet.transfer(2.5, "TO_ADDRESS")

# Transfer 2.5 SPL token
receipt2 = wallet.token_transfer("TOKEN_MINT", 2.5, "TO_ADDRESS")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defi"><a class="header" href="#defi">DeFi</a></h1>
<p>Overview of protocol integrations and adapters provided by Bonanca. This section links into EVM and Solana integrations (Aave, 0x, CoW, Morpho, Jupiter, Kamino, etc.) and shows how to query markets, perform swaps, and manage vaults from Rust and Python.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evm-defi-interfaces"><a class="header" href="#evm-defi-interfaces">EVM DeFi Interfaces</a></h1>
<p>Bonanca provides interfaces to interact with popular DeFi protocols on EVM-compatible blockchains. This section covers the main DeFi integrations available.</p>
<h2 id="aave-v3---lending-protocol"><a class="header" href="#aave-v3---lending-protocol">Aave V3 - Lending Protocol</a></h2>
<p>Aave V3 is a decentralized lending protocol that allows users to supply assets as collateral, borrow tokens, and earn interest. The AaveV3 interface provides methods for managing lending positions.</p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<ul>
<li><strong>Supply</strong>: Deposit tokens to earn interest</li>
<li><strong>Borrow</strong>: Borrow tokens using your collateral</li>
<li><strong>Repay</strong>: Pay back borrowed tokens</li>
<li><strong>Withdraw</strong>: Withdraw supplied tokens</li>
<li><strong>Account Data</strong>: Query user's collateral, debt, and health factor</li>
</ul>
<h3 id="supported-operations"><a class="header" href="#supported-operations">Supported Operations</a></h3>
<h4 id="rust-13"><a class="header" href="#rust-13">Rust</a></h4>
<pre><code class="language-rust ignore">use bonanca::defi::AaveV3;
use bonanca::wallets::evm::EvmWallet;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Initialize wallet
    let wallet = EvmWallet::new(
        "private_key",
        "rpc_url",
        137  // Chain ID for Polygon
    )?;

    // Initialize Aave V3 for Polygon (chain_id=137)
    let aave = AaveV3::new(137);

    // Example 1: Supply USDC
    let usdc_address = "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359";
    let receipt = aave.supply(&amp;wallet, usdc_address, 100.0).await?;
    println!("Supply tx: {:?}", receipt.transaction_hash);

    // Example 2: Check user account data
    let user_data = aave.get_user_data(
        &amp;wallet.pubkey.to_string(),
        &amp;wallet.client
    ).await?;
    println!("Health Factor: {}", user_data.health_factor);
    println!("Total Collateral: {}", user_data.total_collateral);
    println!("Total Debt: {}", user_data.total_debt);
    println!("Available Borrows: {}", user_data.available_borrows);

    // Example 3: Borrow WETH
    let weth_address = "0x7ceB23fD6bC0adD59E27f9EA9d0231e0f01cc726";
    let borrow_receipt = aave.borrow(&amp;wallet, weth_address, 0.5).await?;
    println!("Borrow tx: {:?}", borrow_receipt.transaction_hash);

    // Example 4: Repay borrowed tokens
    let repay_receipt = aave.repay(&amp;wallet, weth_address, 0.3).await?;
    println!("Repay tx: {:?}", repay_receipt.transaction_hash);

    // Example 5: Withdraw collateral
    let withdraw_receipt = aave.withdraw(&amp;wallet, usdc_address, 50.0).await?;
    println!("Withdraw tx: {:?}", withdraw_receipt.transaction_hash);

    Ok(())
}</code></pre>
<h4 id="python-12"><a class="header" href="#python-12">Python</a></h4>
<pre><code class="language-python">import bonanca

# Initialize wallet
wallet = bonanca.wallets.EvmWallet(
    "private_key",
    "https://polygon-rpc.com",
    137  # Chain ID for Polygon
)

# Initialize Aave V3
aave = bonanca.defi.AaveV3(137)

# Token addresses on Polygon
usdc = "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359"
weth = "0x7ceB23fD6bC0adD59E27f9EA9d0231e0f01cc726"

# Supply tokens
supply_receipt = aave.supply(wallet, usdc, 100.0)
print(f"Supply tx: {supply_receipt['transaction_hash']}")

# Check account data
account_data = aave.get_user_data(wallet.pubkey, wallet)
print(f"Health Factor: {account_data['Health Factor']}")
print(f"Total Collateral: {account_data['Total Collateral']}")
print(f"Total Debt: {account_data['Total Debt']}")

# Borrow tokens
borrow_receipt = aave.borrow(wallet, weth, 0.5)
print(f"Borrow tx: {borrow_receipt['transaction_hash']}")

# Repay debt
repay_receipt = aave.repay(wallet, weth, 0.3)
print(f"Repay tx: {repay_receipt['transaction_hash']}")

# Withdraw collateral
withdraw_receipt = aave.withdraw(wallet, usdc, 50.0)
print(f"Withdraw tx: {withdraw_receipt['transaction_hash']}")
</code></pre>
<h3 id="chain-ids"><a class="header" href="#chain-ids">Chain IDs</a></h3>
<p>Common Aave V3 deployments:</p>
<ul>
<li>Ethereum: 1</li>
<li>Polygon: 137</li>
<li>Arbitrum: 42161</li>
<li>Optimism: 10</li>
<li>Base: 8453</li>
<li>Avalanche: 43114</li>
</ul>
<h3 id="important-notes"><a class="header" href="#important-notes">Important Notes</a></h3>
<ul>
<li>Ensure sufficient collateral before borrowing</li>
<li>Monitor your health factor to avoid liquidation</li>
<li>The health factor formula considers collateral and debt ratios</li>
<li>Interest rates vary based on market utilization</li>
<li>Requires token approval before first interaction with Aave</li>
</ul>
<hr />
<h2 id="cow-coincidence-of-wants---dex-aggregator"><a class="header" href="#cow-coincidence-of-wants---dex-aggregator">CoW (Coincidence of Wants) - DEX Aggregator</a></h2>
<p>CoW is an order-based DEX aggregator that uses batch auctions to execute trades. It supports both market orders and limit orders.</p>
<h3 id="overview-1"><a class="header" href="#overview-1">Overview</a></h3>
<ul>
<li><strong>Market Orders</strong>: Execute immediately at best available price</li>
<li><strong>Limit Orders</strong>: Execute only when price reaches your target</li>
<li><strong>Order Queries</strong>: Check order status and history</li>
<li><strong>EIP-712 Signing</strong>: Secure order signing</li>
</ul>
<h3 id="supported-operations-1"><a class="header" href="#supported-operations-1">Supported Operations</a></h3>
<h4 id="rust-14"><a class="header" href="#rust-14">Rust</a></h4>
<pre><code class="language-rust ignore">use bonanca::defi::CoW;
use bonanca::wallets::evm::EvmWallet;
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let wallet = EvmWallet::new(
        "private_key",
        "https://polygon-rpc.com",
        137
    )?;

    // Initialize CoW for Polygon
    let cow = CoW::new("polygon")?;

    let weth = "0x7ceB23fD6bC0adD59E27f9EA9d0231e0f01cc726";
    let usdc = "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359";

    // Example 1: Execute market order (WETH → USDC)
    let market_quote = cow.get_market_quote(
        &amp;wallet,
        weth,
        usdc,
        0.1  // 0.1 WETH
    ).await?;

    let order_uid = cow.post_market_order(
        &amp;wallet,
        market_quote
    ).await?;
    println!("Market order placed: {}", order_uid);

    // Example 2: Check order status
    let order_info = cow.get_order_info(&amp;order_uid).await?;
    println!("Status: {}", order_info.status);
    println!("Executed Buy Amount: {}", order_info.executed_buy_amount);
    println!("Executed Sell Amount: {}", order_info.executed_sell_amount);

    // Example 3: Get user order history
    let user_orders = cow.get_user_orders(
        &amp;wallet.pubkey.to_string(),
        Some(10)  // Last 10 orders
    ).await?;
    println!("Recent orders: {} found", user_orders.len());

    // Example 4: Place limit order
    // Valid for 1 hour (60 minutes + 0 seconds)
    let limit_duration = Duration::new(3600, 0);
    let limit_uid = cow.limit_order(
        &amp;wallet,
        weth,      // Selling WETH
        usdc,      // Buying USDC
        0.1,       // Sell amount
        200.0,     // Buy amount (minimum)
        limit_duration
    ).await?;
    println!("Limit order placed: {}", limit_uid);

    // Example 5: Place limit order by price
    let price_limit_uid = cow.limit_order_by_price(
        &amp;wallet,
        weth,
        usdc,
        0.1,       // Amount of WETH to sell
        2000.0,    // Minimum price (USDC per WETH)
        limit_duration
    ).await?;
    println!("Price limit order placed: {}", price_limit_uid);

    Ok(())
}</code></pre>
<h4 id="python-13"><a class="header" href="#python-13">Python</a></h4>
<pre><code class="language-python">import bonanca

wallet = bonanca.wallets.EvmWallet(
    "private_key",
    "https://polygon-rpc.com",
    137
)

# Initialize CoW for Polygon
cow = bonanca.defi.CoW("polygon")

weth = "0x7ceB23fD6bC0adD59E27f9EA9d0231e0f01cc726"
usdc = "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359"

# Market order: Sell 0.1 WETH for USDC
order_uid = cow.market_order(wallet, weth, usdc, 0.1)
print(f"Order UID: {order_uid}")

# Get order details
order_info = cow.get_order_info(order_uid)
print(f"Status: {order_info['status']}")
print(f"Buy Amount: {order_info['executed_buy_amount']}")
print(f"Sell Amount: {order_info['executed_sell_amount']}")

# Get all orders for a user
user_orders = cow.get_user_orders(wallet.pubkey, 10)
print(f"Found {len(user_orders)} recent orders")

# Limit order: Sell 0.1 WETH for minimum 200 USDC, valid for 1 hour
limit_uid = cow.limit_order(
    wallet,
    weth,               # Sell token
    usdc,               # Buy token
    0.1,                # Sell amount
    200.0,              # Minimum buy amount
    (1, 0)              # Duration: 1 hour, 0 minutes
)
print(f"Limit order: {limit_uid}")

# Limit order by price
price_uid = cow.limit_order_by_price(
    wallet,
    weth,
    usdc,
    0.1,                # Amount to sell
    2000.0,             # Minimum price
    (1, 0)              # Duration
)
print(f"Price limit order: {price_uid}")
</code></pre>
<h3 id="supported-chains"><a class="header" href="#supported-chains">Supported Chains</a></h3>
<ul>
<li>Ethereum (mainnet)</li>
<li>Polygon</li>
<li>Arbitrum</li>
<li>Optimism</li>
<li>Base</li>
<li>Gnosis Chain (xDai)</li>
<li>Linea</li>
<li>Avalanche</li>
<li>BNB Chain</li>
</ul>
<h3 id="important-notes-1"><a class="header" href="#important-notes-1">Important Notes</a></h3>
<ul>
<li>CoW Protocol uses batch auctions for better pricing</li>
<li>Limit orders expire after specified duration</li>
<li>Orders must be signed with EIP-712</li>
<li>Focus on MEV protection compared to traditional DEXs</li>
<li>No gas required for failed orders</li>
</ul>
<hr />
<h2 id="morpho---lending-optimization"><a class="header" href="#morpho---lending-optimization">Morpho - Lending Optimization</a></h2>
<p>Morpho optimizes lending by matching users peer-to-peer while falling back to lending pools. The MorphoVaultV1 interface provides access to Morpho vaults.</p>
<h3 id="overview-2"><a class="header" href="#overview-2">Overview</a></h3>
<ul>
<li><strong>Supply</strong>: Deposit into optimized vaults</li>
<li><strong>Withdraw</strong>: Withdraw from vaults</li>
<li><strong>Vault Data</strong>: Query available vaults for specific tokens</li>
<li><strong>User Positions</strong>: Track user's vault positions</li>
</ul>
<h3 id="supported-operations-2"><a class="header" href="#supported-operations-2">Supported Operations</a></h3>
<h4 id="rust-15"><a class="header" href="#rust-15">Rust</a></h4>
<pre><code class="language-rust ignore">use bonanca::defi::MorphoVaultV1;
use bonanca::wallets::evm::EvmWallet;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let wallet = EvmWallet::new(
        "private_key",
        "https://polygon-rpc.com",
        137
    )?;

    let morpho = MorphoVaultV1::new();

    // Example 1: Get user's vault positions
    let user_positions = morpho.get_user_data(
        &amp;wallet.pubkey.to_string(),
        137  // Chain ID
    ).await?;
    println!("User positions: {:?}", user_positions);

    // Example 2: Find USDC vaults
    let usdc_vaults = morpho.get_token_vaults(
        "USDC",
        137
    ).await?;
    println!("Available USDC vaults: {}", usdc_vaults.len());
    for vault in &amp;usdc_vaults {
        println!("Vault: {:?}", vault);
    }

    // Example 3: Supply to a vault
    // First, get a vault address from get_token_vaults()
    let vault_address = "0x..."; // Example vault address
    let deposit_receipt = morpho.supply(
        &amp;wallet,
        vault_address,
        100.0  // Amount in decimal format
    ).await?;
    println!("Deposit tx: {:?}", deposit_receipt.transaction_hash);

    // Example 4: Withdraw from vault
    let withdraw_receipt = morpho.withdraw(
        &amp;wallet,
        vault_address,
        50.0
    ).await?;
    println!("Withdraw tx: {:?}", withdraw_receipt.transaction_hash);

    Ok(())
}</code></pre>
<h4 id="python-14"><a class="header" href="#python-14">Python</a></h4>
<pre><code class="language-python">import bonanca

wallet = bonanca.wallets.EvmWallet(
    "private_key",
    "https://polygon-rpc.com",
    137
)

morpho = bonanca.defi.MorphoVaultV1()

# Get user's vault positions
user_data = morpho.get_user_data(wallet.pubkey, 137, wallet)
print(f"User positions: {user_data}")

# Find USDC vaults
usdc_vaults = morpho.get_token_vaults("USDC", 137, wallet)
print(f"Available vaults: {usdc_vaults}")

# Supply to a vault (replace with actual vault address)
vault_address = "0x..."
deposit_receipt = morpho.supply(wallet, vault_address, 100.0)
print(f"Deposit tx: {deposit_receipt['transaction_hash']}")

# Withdraw from vault
withdraw_receipt = morpho.withdraw(wallet, vault_address, 50.0)
print(f"Withdraw tx: {withdraw_receipt['transaction_hash']}")
</code></pre>
<h3 id="morpho-vaults"><a class="header" href="#morpho-vaults">Morpho Vaults</a></h3>
<p>Morpho offers specialized vaults for different strategies:</p>
<ul>
<li><strong>USDC Vaults</strong>: Stable yield on USDC</li>
<li><strong>WETH Vaults</strong>: Ethereum staking</li>
<li><strong>Strategy Vaults</strong>: Custom yield strategies</li>
<li><strong>Metamorpho Vaults</strong>: User-created vault bundles</li>
</ul>
<h3 id="important-notes-2"><a class="header" href="#important-notes-2">Important Notes</a></h3>
<ul>
<li>Vault addresses vary by chain</li>
<li>Deposits are immediately invested</li>
<li>Withdrawals may take time depending on vault liquidity</li>
<li>Each vault has different risk/reward profiles</li>
<li>Query vault details for APY and TVL information</li>
</ul>
<hr />
<h2 id="0x-zerox---dex-aggregator"><a class="header" href="#0x-zerox---dex-aggregator">0x (ZeroX) - DEX Aggregator</a></h2>
<p>0x is a decentralized exchange aggregator that sources liquidity from multiple DEXs to find the best prices for token swaps.</p>
<h3 id="overview-3"><a class="header" href="#overview-3">Overview</a></h3>
<ul>
<li><strong>Swap Quotes</strong>: Get best available swap prices</li>
<li><strong>Quick Swaps</strong>: Execute swaps in one transaction</li>
<li><strong>Issue Checking</strong>: Verify swap feasibility</li>
<li><strong>Multi-source Routing</strong>: Optimal liquidity from multiple DEXs</li>
</ul>
<h3 id="supported-operations-3"><a class="header" href="#supported-operations-3">Supported Operations</a></h3>
<h4 id="rust-16"><a class="header" href="#rust-16">Rust</a></h4>
<pre><code class="language-rust ignore">use bonanca::defi::ZeroX;
use bonanca::wallets::evm::EvmWallet;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let wallet = EvmWallet::new(
        "private_key",
        "https://polygon-rpc.com",
        137
    )?;

    // Initialize 0x with API key (get from 0x.org)
    let zerox = ZeroX::new("your_api_key".to_string(), 137);

    let weth = "0x7ceB23fD6bC0adD59E27f9EA9d0231e0f01cc726";
    let usdc = "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359";

    // Example 1: Check for swap issues
    let issues = zerox.check_swap(
        &amp;wallet,
        weth,
        usdc,
        0.1  // 0.1 WETH
    ).await?;

    if issues.allowance.is_some() {
        println!("Token approval required");
    }
    if issues.balance.is_some() {
        println!("Insufficient balance");
    }

    // Example 2: Get swap quote
    let quote = zerox.get_swap_quote(
        &amp;wallet,
        weth,
        usdc,
        0.1
    ).await?;

    println!("Buy Amount: {}", quote.buy_amount);
    println!("Min Buy Amount: {}", quote.min_buy_amount);
    println!("Liquidity Available: {}", quote.liquidity_available);
    println!("Allowance Target: {}", quote.allowance_target);

    // Example 3: Execute swap with quote
    let swap_receipt = zerox.swap(
        &amp;wallet,
        quote
    ).await?;
    println!("Swap tx: {:?}", swap_receipt.transaction_hash);

    // Example 4: Quick swap (get quote and swap in one call)
    // This is more convenient for simpler scenarios
    let receipt = zerox.quick_swap(
        &amp;wallet,
        weth,
        usdc,
        0.1
    ).await?;
    println!("Quick swap tx: {:?}", receipt.transaction_hash);

    Ok(())
}</code></pre>
<h4 id="python-15"><a class="header" href="#python-15">Python</a></h4>
<pre><code class="language-python">import bonanca

wallet = bonanca.wallets.EvmWallet(
    "private_key",
    "https://polygon-rpc.com",
    137
)

# Initialize 0x (replace with actual API key from 0x.org)
zerox = bonanca.defi.ZeroX("api_key", 137)

weth = "0x7ceB23fD6bC0adD59E27f9EA9d0231e0f01cc726"
usdc = "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359"

# Check for swap issues (allowance, balance)
issues = zerox.check_swap(wallet, weth, usdc, 0.1)
print(f"Issues: {issues}")

# Get detailed quote
quote = zerox.get_swap_quote(wallet, weth, usdc, 0.1)
print(f"Buy Amount: {quote.buy_amount}")
print(f"Min Buy Amount: {quote.min_buy_amount}")
print(f"Liquidity Available: {quote.liquidity_available}")

# Execute swap with quote
swap_receipt = zerox.swap(wallet, quote)
print(f"Swap tx: {swap_receipt['transaction_hash']}")

# Quick swap (recommended for simple swaps)
quick_receipt = zerox.quick_swap(wallet, weth, usdc, 0.1)
print(f"Quick swap tx: {quick_receipt['transaction_hash']}")
</code></pre>
<h3 id="supported-chains-1"><a class="header" href="#supported-chains-1">Supported Chains</a></h3>
<ul>
<li>Ethereum</li>
<li>Polygon</li>
<li>Arbitrum</li>
<li>Optimism</li>
<li>Base</li>
<li>Avalanche</li>
<li>BNB Chain</li>
<li>Linea</li>
<li>Scroll</li>
</ul>
<h3 id="quote-information"><a class="header" href="#quote-information">Quote Information</a></h3>
<p>The swap quote returns:</p>
<ul>
<li><strong>buy_amount</strong>: Exact amount of output tokens</li>
<li><strong>min_buy_amount</strong>: Minimum considering slippage</li>
<li><strong>sell_amount</strong>: Amount of input tokens</li>
<li><strong>allowance_target</strong>: Address to approve for token spending</li>
<li><strong>liquidity_available</strong>: Whether sufficient liquidity exists</li>
</ul>
<h3 id="important-notes-3"><a class="header" href="#important-notes-3">Important Notes</a></h3>
<ul>
<li>Requires 0x API key (free tier available)</li>
<li>Always check issues before executing trades</li>
<li>Slippage is automatically handled</li>
<li>Gas estimates included in quotes</li>
<li>Quote validity is typically 1 minute</li>
<li>Quick swaps are simpler but less flexible than manual swap flow</li>
</ul>
<hr />
<h2 id="general-best-practices"><a class="header" href="#general-best-practices">General Best Practices</a></h2>
<h3 id="security"><a class="header" href="#security">Security</a></h3>
<ol>
<li>
<p><strong>Private Key Management</strong></p>
<ul>
<li>Never hardcode private keys</li>
<li>Use environment variables or secure vaults</li>
<li>Rotate keys regularly</li>
</ul>
</li>
<li>
<p><strong>Token Approval</strong></p>
<ul>
<li>Check allowances before transactions</li>
<li>Use minimal necessary amounts</li>
<li>Revoke approvals when done</li>
</ul>
</li>
<li>
<p><strong>Position Management</strong></p>
<ul>
<li>Monitor health factors in lending protocols</li>
<li>Set alerts for liquidation risk</li>
<li>Rebalance positions regularly</li>
</ul>
</li>
</ol>
<h3 id="gas-optimization"><a class="header" href="#gas-optimization">Gas Optimization</a></h3>
<ul>
<li>Batch multiple operations when possible</li>
<li>Use limit orders for time-insensitive trades</li>
<li>Monitor gas prices before executing</li>
<li>Consider network congestion</li>
</ul>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<ul>
<li>Test on testnet before mainnet</li>
<li>Start with small amounts</li>
<li>Verify transactions before committing funds</li>
<li>Use price impact slippage limits</li>
</ul>
<h3 id="transaction-confirmation"><a class="header" href="#transaction-confirmation">Transaction Confirmation</a></h3>
<p>All operations return transaction receipts containing:</p>
<ul>
<li>Transaction hash</li>
<li>Block number</li>
<li>Gas used</li>
<li>Transaction status</li>
</ul>
<p>Always verify successful execution before relying on results.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solana-defi-interfaces"><a class="header" href="#solana-defi-interfaces">Solana DeFi Interfaces</a></h1>
<p>Bonanca provides interfaces to interact with popular DeFi protocols on Solana. This section covers the main DeFi integrations available.</p>
<h2 id="jupiter---dex-aggregator"><a class="header" href="#jupiter---dex-aggregator">Jupiter - DEX Aggregator</a></h2>
<p>Jupiter is the leading decentralized exchange aggregator on Solana, sourcing liquidity from multiple DEXs to find the best prices for token swaps. It also offers a lending protocol called Jupiter Earn.</p>
<h3 id="overview-4"><a class="header" href="#overview-4">Overview</a></h3>
<ul>
<li><strong>Token Swaps</strong>: Get best pricing across multiple Solana DEXs</li>
<li><strong>Limit Orders</strong>: Place orders that execute at specified prices</li>
<li><strong>Price Queries</strong>: Check token prices and value conversions</li>
<li><strong>Lending/Earn</strong>: Deposit tokens to earn yield</li>
<li><strong>Lendable Markets</strong>: Query available lending markets</li>
</ul>
<h3 id="supported-operations-4"><a class="header" href="#supported-operations-4">Supported Operations</a></h3>
<h4 id="rust-17"><a class="header" href="#rust-17">Rust</a></h4>
<pre><code class="language-rust ignore">use bonanca::defi::Jupiter;
use bonanca::wallets::solana::SolWallet;
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Initialize wallet
    let wallet = SolWallet::new(
        "base58_private_key",
        "https://api.mainnet-beta.solana.com"
    )?;

    // Initialize Jupiter with API key
    let jupiter = Jupiter::new("your_api_key".to_string());

    // Token mint addresses
    let sol = "So11111111111111111111111111111111111111112";
    let usdc = "EPjFWdd5Au17FXxeB6VWyeXKSa3LvwV0LCH7f3uyxVEP";
    let orca = "orcaEKTdK7LKz57chYcUBK6GDZT5bNvmnucEZDfmWQe";

    // Example 1: Get token price in USD
    let sol_price = jupiter.get_token_price(token_mint, 1.0).await?;
    println!("1 SOL = ${}", sol_price);

    // Example 2: Get swap quote
    let quote = jupiter.get_swap_quote(
        &amp;wallet,
        sol,      // Sell token (SOL)
        usdc,     // Buy token (USDC)
        1.0       // Amount in decimal format
    ).await?;

    println!("Input Amount: {}", quote.in_amount);
    println!("Output Amount: {}", quote.out_amount);
    println!("Price Impact: {}%", quote.price_impact_pct);
    println!("Slippage (bps): {}", quote.slippage_bps);

    // Example 3: Execute swap with quote
    let swap_receipt = jupiter.swap(&amp;wallet, quote).await?;
    println!("Swap signature: {}", swap_receipt.hash);
    println!("Slot: {}", swap_receipt.slot);

    // Example 4: Quick swap (get quote and swap in one call)
    let receipt = jupiter.quick_swap(
        &amp;wallet,
        sol,
        usdc,
        1.0
    ).await?;
    println!("Quick swap signature: {}", receipt.hash);

    // Example 5: Place limit order
    // Order is valid for 24 hours (86400 seconds)
    let limit_receipt = jupiter.limit_order(
        &amp;wallet,
        sol,           // Sell token
        usdc,          // Buy token
        1.0,           // Amount to sell
        34.5,          // Minimum to receive
        Duration::from_secs(86400)
    ).await?;
    println!("Limit order signature: {}", limit_receipt.hash);

    // Example 6: Limit order by price
    // Sell 1 SOL if price reaches 35 USDC per SOL
    let price_limit_receipt = jupiter.limit_order_by_price(
        &amp;wallet,
        sol,
        usdc,
        1.0,                  // Amount to sell
        35.0,                 // Price threshold
        Duration::from_secs(86400)
    ).await?;
    println!("Price limit order: {}", price_limit_receipt.hash);

    // Example 7: Get available lending markets
    let markets = jupiter.get_lendable_tokens().await?;
    for market in &amp;markets {
        println!("Market: {} ({})", market.name, market.symbol);
        println!("  Supply Rate: {}", market.supply_rate);
        println!("  Total Assets: {}", market.total_assets);
        println!("  Total Supply: {}", market.total_supply);
    }

    // Example 8: Deposit into lending market
    let deposit_receipt = jupiter.deposit(
        &amp;wallet,
        usdc,   // Token to deposit
        100.0   // Amount in decimal format
    ).await?;
    println!("Deposit signature: {}", deposit_receipt.hash);

    // Example 9: Withdraw from lending market
    let withdraw_receipt = jupiter.withdraw(
        &amp;wallet,
        usdc,
        50.0
    ).await?;
    println!("Withdraw signature: {}", withdraw_receipt.hash);

    Ok(())
}</code></pre>
<h4 id="python-16"><a class="header" href="#python-16">Python</a></h4>
<pre><code class="language-python">import bonanca
import time

# Initialize wallet
wallet = bonanca.wallets.SolWallet(
    "base58_private_key",
    "https://api.mainnet-beta.solana.com"
)

# Initialize Jupiter
jupiter = bonanca.defi.Jupiter("your_api_key")

# Token mint addresses
sol = "So11111111111111111111111111111111111111112"
usdc = "EPjFWdd5Au17FXxeB6VWyeXKSa3LvwV0LCH7f3uyxVEP"
orca = "orcaEKTdK7LKz57chYcUBK6GDZT5bNvmnucEZDfmWQe"

# Get token price
sol_price = jupiter.get_token_price(wallet, sol, 1.0)
print(f"1 SOL = ${sol_price}")

# Get swap quote
quote = jupiter.get_swap_quote(wallet, sol, usdc, 1.0)
print(f"Input: {quote.in_amount}")
print(f"Output: {quote.out_amount}")
print(f"Price Impact: {quote.price_impact_pct}%")

# Execute swap
swap_receipt = jupiter.swap(wallet, quote)
print(f"Swap tx: {swap_receipt.hash}")

# Quick swap (simpler one-liner)
receipt = jupiter.quick_swap(wallet, sol, usdc, 1.0)
print(f"Quick swap tx: {receipt.hash}")

# Limit order (valid for 1 day = 86400 seconds)
limit_receipt = jupiter.limit_order(
    wallet,
    sol,              # Sell token
    usdc,             # Buy token
    1.0,              # Amount to sell
    34.5,             # Minimum to receive
    86400             # Lifetime in seconds
)
print(f"Limit order: {limit_receipt.hash}")

# Price-based limit order
price_receipt = jupiter.limit_order_by_price(
    wallet,
    sol,
    usdc,
    1.0,              # Amount to sell
    35.0,             # Price threshold
    86400
)
print(f"Price limit: {price_receipt.hash}")

# Get available lending markets
markets = jupiter.get_lendable_tokens(wallet)
for market in markets:
    print(f"Market: {market.name} ({market.symbol})")
    print(f"  APY: {market.supply_rate}")
    print(f"  TVL: {market.total_assets}")

# Deposit into lending protocol
deposit_receipt = jupiter.deposit(wallet, usdc, 100.0)
print(f"Deposit tx: {deposit_receipt.hash}")

# Withdraw from lending protocol
withdraw_receipt = jupiter.withdraw(wallet, usdc, 50.0)
print(f"Withdraw tx: {withdraw_receipt.hash}")
</code></pre>
<h3 id="quote-structure"><a class="header" href="#quote-structure">Quote Structure</a></h3>
<p>The swap quote includes:</p>
<ul>
<li><strong>in_amount</strong>: Exact input amount needed</li>
<li><strong>out_amount</strong>: Expected output amount</li>
<li><strong>other_amount_threshold</strong>: Minimum output considering slippage</li>
<li><strong>price_impact_pct</strong>: Price impact percentage</li>
<li><strong>slippage_bps</strong>: Slippage in basis points</li>
<li><strong>context_slot</strong>: Slot when quote was created</li>
<li><strong>swap_mode</strong>: Type of swap (ExactIn, ExactOut)</li>
</ul>
<h3 id="lending-markets"><a class="header" href="#lending-markets">Lending Markets</a></h3>
<p>Jupiter Earn provides lending markets with:</p>
<ul>
<li><strong>supply_rate</strong>: Current APY for deposits</li>
<li><strong>total_assets</strong>: Total assets in the market</li>
<li><strong>total_supply</strong>: Total supply shares issued</li>
<li><strong>decimals</strong>: Token decimal places</li>
<li><strong>symbol</strong>: Token symbol</li>
</ul>
<h3 id="api-key"><a class="header" href="#api-key">API Key</a></h3>
<p>Get a free API key from <a href="https://jup.ag/">Jupiter</a>:</p>
<ul>
<li>Free tier available for development</li>
<li>Rate limits apply</li>
<li>Required for production swaps</li>
</ul>
<hr />
<h2 id="kamino---yield-optimization-vaults"><a class="header" href="#kamino---yield-optimization-vaults">Kamino - Yield Optimization Vaults</a></h2>
<p>Kamino is a vault protocol on Solana that optimizes yield strategies by allocating assets across multiple lending markets. Kamino vaults provide automated yield farming and lending strategies.</p>
<h3 id="overview-5"><a class="header" href="#overview-5">Overview</a></h3>
<ul>
<li><strong>Vault Discovery</strong>: Find vaults by name, ID, or underlying token</li>
<li><strong>Vault Metrics</strong>: APY, TVL, performance tracking</li>
<li><strong>Position Management</strong>: Deposit and withdraw from vaults</li>
<li><strong>User Positions</strong>: Track vault holdings across all vaults</li>
<li><strong>Strategy Allocation</strong>: Vaults allocate across KLend reserves</li>
</ul>
<h3 id="important-note"><a class="header" href="#important-note">Important Note</a></h3>
<p>Kamino is currently available in <strong>Rust only</strong>. Python bindings are not yet available. The interface requires direct interaction with the Kamino smart contracts via Anchor.</p>
<h3 id="supported-operations-rust-only"><a class="header" href="#supported-operations-rust-only">Supported Operations (Rust Only)</a></h3>
<pre><code class="language-rust ignore">use bonanca::defi::Kamino;
use bonanca::wallets::solana::SolWallet;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let wallet = SolWallet::new(
        "base58_private_key",
        "https://api.mainnet-beta.solana.com"
    )?;

    let kamino = Kamino::new();

    // Example 1: Get all available vaults
    let all_vaults = kamino.get_vaults().await?;
    println!("Total vaults: {}", all_vaults.len());
    for vault in &amp;all_vaults {
        println!("Vault: {} ({})", vault.state.name, vault.address);
        println!("  Token: {}", vault.state.token_mint);
        println!("  APY: {}", vault.state.name);
    }

    // Example 2: Find vault by name
    let usdc_vault = kamino.get_vault_data_by_name("Kamino USDC")
        .await?;
    println!("USDC Vault Address: {}", usdc_vault.address);

    // Example 3: Find vault by ID
    let vault_id = "7i..."; // Vault address
    let vault_data = kamino.get_vault_data_by_id(vault_id).await?;
    println!("Vault Name: {}", vault_data.state.name);

    // Example 4: Get user's vault positions
    let positions = kamino.get_user_data(&amp;wallet.pubkey.to_string()).await?;
    println!("User positions: {}", positions.len());
    for position in &amp;positions {
        println!("Vault: {}", position.vault_address);
        println!("  Staked Shares: {}", position.staked_shares);
        println!("  Unstaked Shares: {}", position.unstaked_shares);
        println!("  Total Shares: {}", position.total_shares);
    }

    // Example 5: Find all USDC vaults
    let usdc_mint = "EPjFWdd5Au17FXxeB6VWyeXKSa3LvwV0LCH7f3uyxVEP";
    let usdc_vaults = kamino.get_token_vaults(usdc_mint).await?;
    println!("USDC vaults available: {}", usdc_vaults.len());

    // Example 6: Deposit into a vault
    let vault = kamino.get_vault_data_by_name("Kamino USDC").await?;
    kamino.supply(&amp;wallet, &amp;vault, 1000.0).await?;
    println!("Deposited 1000 USDC into vault");

    // Example 7: Withdraw from a vault
    kamino.withdraw(&amp;wallet, &amp;vault, 500.0).await?;
    println!("Withdrew 500 USDC from vault");

    // Example 8: Monitor vault performance
    println!("\nVault Details:");
    println!("  Name: {}", vault.state.name);
    println!("  Token Mint: {}", vault.state.token_mint);
    println!("  Shares Mint: {}", vault.state.shares_mint);
    println!("  Total Shares Issued: {}", vault.state.shares_issued);
    println!("  Performance Fee: {} bps", vault.state.performance_fee_bps);
    println!("  Management Fee: {} bps", vault.state.management_fee_bps);

    Ok(())
}</code></pre>
<h3 id="vault-information"><a class="header" href="#vault-information">Vault Information</a></h3>
<p>Each vault provides detailed information:</p>
<ul>
<li><strong>name</strong>: Human-readable vault name</li>
<li><strong>token_mint</strong>: The token deposited in this vault</li>
<li><strong>shares_mint</strong>: The receipt token for vault shares</li>
<li><strong>address</strong>: Vault account address</li>
<li><strong>token_available</strong>: Amount available for withdrawal</li>
<li><strong>shares_issued</strong>: Total shares in circulation</li>
<li><strong>performance_fee_bps</strong>: Fee on profits (basis points)</li>
<li><strong>management_fee_bps</strong>: Annual management fee</li>
<li><strong>vault_allocation_strategy</strong>: How tokens are allocated across reserves</li>
</ul>
<h3 id="vault-allocation"><a class="header" href="#vault-allocation">Vault Allocation</a></h3>
<p>Kamino vaults automatically allocate deposits across multiple lending reserves:</p>
<ul>
<li>Optimizes yield across KLend markets</li>
<li>Rebalances automatically</li>
<li>Charges performance and management fees</li>
<li>Reinvests earned interest</li>
</ul>
<h3 id="user-positions"><a class="header" href="#user-positions">User Positions</a></h3>
<p>Track positions across all vaults:</p>
<ul>
<li><strong>staked_shares</strong>: Shares in staking/earning strategies</li>
<li><strong>unstaked_shares</strong>: Shares not yet fully invested</li>
<li><strong>total_shares</strong>: Total position size</li>
<li>One entry per vault per user</li>
</ul>
<h3 id="fee-structure"><a class="header" href="#fee-structure">Fee Structure</a></h3>
<ul>
<li><strong>Performance Fee</strong>: Percentage of earned yield (in basis points)</li>
<li><strong>Management Fee</strong>: Annual fee charged (in basis points)</li>
<li><strong>Example</strong>: 10% performance fee = 1000 bps, 1% management fee = 100 bps</li>
</ul>
<hr />
<h2 id="swap-best-practices"><a class="header" href="#swap-best-practices">Swap Best Practices</a></h2>
<h3 id="general-guidelines"><a class="header" href="#general-guidelines">General Guidelines</a></h3>
<ol>
<li>
<p><strong>Slippage Management</strong></p>
<ul>
<li>Always check <code>other_amount_threshold</code> on quotes</li>
<li>Jupiter automatically handles slippage configuration</li>
<li>Adjust slippage for volatile markets</li>
</ul>
</li>
<li>
<p><strong>Quote Validity</strong></p>
<ul>
<li>Quotes are typically valid for ~30 seconds</li>
<li>Refresh quotes before executing large swaps</li>
<li>Use quick_swap for time-sensitive trades</li>
</ul>
</li>
<li>
<p><strong>Price Impact</strong></p>
<ul>
<li>Monitor <code>price_impact_pct</code> in quotes</li>
<li>Larger swaps have higher price impact</li>
<li>Consider breaking into smaller swaps if &gt; 5% impact</li>
</ul>
</li>
</ol>
<h3 id="limit-order-strategy"><a class="header" href="#limit-order-strategy">Limit Order Strategy</a></h3>
<ul>
<li>
<p><strong>Expiration</strong>: Set lifetime based on trading frequency</p>
<ul>
<li>Short-term: 1-24 hours</li>
<li>Day trading: 1 hour</li>
<li>Long-term: 7+ days</li>
</ul>
</li>
<li>
<p><strong>Order Amounts</strong></p>
<ul>
<li>limit_order takes exact amounts</li>
<li>limit_order_by_price calculates amounts from price</li>
</ul>
</li>
<li>
<p><strong>Order Book</strong></p>
<ul>
<li>Limit orders wait for market to reach your price</li>
<li>No execution guarantee</li>
<li>Prices are checked continuously</li>
</ul>
</li>
</ul>
<h2 id="vault-management-best-practices"><a class="header" href="#vault-management-best-practices">Vault Management Best Practices</a></h2>
<h3 id="deposit-strategy"><a class="header" href="#deposit-strategy">Deposit Strategy</a></h3>
<ol>
<li>
<p><strong>Find Appropriate Vault</strong></p>
<ul>
<li>Check vault APY and TVL</li>
<li>Verify vault allocation strategy</li>
<li>Review fee structure</li>
</ul>
</li>
<li>
<p><strong>Monitor Positions</strong></p>
<ul>
<li>Track share value over time</li>
<li>Monitor APY changes</li>
<li>Watch fee deductions</li>
</ul>
</li>
<li>
<p><strong>Withdrawal Timing</strong></p>
<ul>
<li>Withdraw when strategy is optimal</li>
<li>Consider gas costs</li>
<li>Account for any lock-up periods</li>
</ul>
</li>
</ol>
<h3 id="risk-management"><a class="header" href="#risk-management">Risk Management</a></h3>
<ul>
<li><strong>Concentration Risk</strong>: Diversify across multiple vaults/tokens</li>
<li><strong>Smart Contract Risk</strong>: Kamino/KLend are audited but not risk-free</li>
<li><strong>Market Risk</strong>: Underlying tokens can be volatile</li>
<li><strong>Strategy Risk</strong>: Allocations may not perform as expected</li>
</ul>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="simple-swap"><a class="header" href="#simple-swap">Simple Swap</a></h3>
<pre><code class="language-rust ignore">let receipt = jupiter.quick_swap(&amp;wallet, sell_token, buy_token, 1.0).await?;</code></pre>
<h3 id="quoted-swap"><a class="header" href="#quoted-swap">Quoted Swap</a></h3>
<pre><code class="language-rust ignore">let quote = jupiter.get_swap_quote(&amp;wallet, sell, buy, amount).await?;
// Check quote before proceeding
let receipt = jupiter.swap(&amp;wallet, quote).await?;</code></pre>
<h3 id="deposit-to-earn"><a class="header" href="#deposit-to-earn">Deposit to Earn</a></h3>
<pre><code class="language-rust ignore">let markets = jupiter.get_lendable_tokens().await?;
// Find market with best APY
let receipt = jupiter.deposit(&amp;wallet, chosen_market, amount).await?;</code></pre>
<h3 id="vault-position-tracking"><a class="header" href="#vault-position-tracking">Vault Position Tracking</a></h3>
<pre><code class="language-rust ignore">let kamino = Kamino::new();
let positions = kamino.get_user_data(&amp;wallet_pubkey).await?;
for position in positions {
    let vault = kamino.get_vault_data_by_id(&amp;position.vault_address).await?;
    println!("Position in {}: {}", vault.state.name, position.total_shares);
}</code></pre>
<h2 id="token-addresses"><a class="header" href="#token-addresses">Token Addresses</a></h2>
<p>Common Solana token addresses:</p>
<ul>
<li><strong>SOL</strong>: So11111111111111111111111111111111111111112</li>
<li><strong>USDC</strong>: EPjFWdd5Au17FXxeB6VWyeXKSa3LvwV0LCH7f3uyxVEP</li>
<li><strong>USDT</strong>: Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenEst</li>
<li><strong>ORCA</strong>: orcaEKTdK7LKz57chYcUBK6GDZT5bNvmnucEZDfmWQe</li>
<li><strong>JUP</strong>: JUPyiwrYJFskidvHPcMj5kLSnsxPJ3Bad7Or7SvxJvP</li>
<li><strong>COPE</strong>: 8HGyAAB1yoM1ttS7pnK6DGPhcF1JSQhQTiNrgQpTsEq</li>
<li><strong>RAY</strong>: 4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX4r</li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="swap-failures"><a class="header" href="#swap-failures">Swap Failures</a></h3>
<ul>
<li><strong>Insufficient Balance</strong>: Ensure wallet has enough tokens</li>
<li><strong>Slippage Exceeded</strong>: Quote may have expired, refresh and try again</li>
<li><strong>Network Congestion</strong>: Retry after waiting or increase priority fee</li>
<li><strong>Liquidity Issues</strong>: Requested pair may not have sufficient liquidity</li>
</ul>
<h3 id="limit-order-issues"><a class="header" href="#limit-order-issues">Limit Order Issues</a></h3>
<ul>
<li><strong>Order Not Filling</strong>: Price may not have reached your target</li>
<li><strong>Expired Order</strong>: Lifetime has passed, create new order</li>
<li><strong>Invalid Amounts</strong>: Ensure amounts are correctly formatted</li>
</ul>
<h3 id="vault-operations"><a class="header" href="#vault-operations">Vault Operations</a></h3>
<ul>
<li><strong>Deposit Fails</strong>: Verify token balance and vault capacity</li>
<li><strong>Withdraw Fails</strong>: Ensure sufficient shares, check vault liquidity</li>
<li><strong>Account Creation</strong>: First interaction with vault may require account setup</li>
</ul>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<ul>
<li>Never share your private key</li>
<li>Use environment variables for sensitive data</li>
<li>Test on devnet before mainnet</li>
<li>Monitor transaction fees and balances</li>
<li>Verify token addresses before trading</li>
<li>Start with small amounts while testing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>A curated collection of example projects and scripts demonstrating common Bonanca workflows. Browse the examples to learn how to run bots, manage index funds, use the scalper, and interact with on-chain protocols in both Rust and Python.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-fund-example"><a class="header" href="#index-fund-example">Index Fund Example</a></h1>
<p>The Index Fund is a Rust-based portfolio management tool that maintains a diversified cryptocurrency index. It allows you to manage a basket of tokens with automatic rebalancing to maintain target weights.</p>
<p>You can see the example code <a href="https://github.com/Cavenfish/bonanca/tree/main/examples/crates/index-fund">here</a>.</p>
<h2 id="features-1"><a class="header" href="#features-1">Features</a></h2>
<ul>
<li>Create and manage a diversified portfolio of cryptocurrencies</li>
<li>Automatic rebalancing to target weights</li>
<li>Multiple rebalancing strategies</li>
</ul>
<h2 id="building-the-project"><a class="header" href="#building-the-project">Building the Project</a></h2>
<pre><code class="language-bash">cd examples/crates/index-fund
cargo build --release
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>This example project build a CLI which includes help docs that cover basic usage.</p>
<pre><code class="language-bash">index --help
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Create an index fund configuration file:</p>
<pre><code class="language-json">{
  "name": "Basic Index Fund",
  "chain": "EVM:Polygon",
  "chain_id": 137,
  "rpc_url": "https://1rpc.io/matic",
  "keyvault": "./keyvault.json",
  "child": 0,
  "max_offset": 0.01,

  "aggregator": {
    "name": "0x",
    "api_key": "API_KEY"
  },

  "oracle": {
    "name": "DefiLlama",
    "api_key": "API_KEY"
  },

  "auxiliary_assets": [
    {
      "name": "Dai Stablecoin",
      "symbol": "DAI",
      "address": "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063"
    }
  ],

  "sectors": [
    {
      "name": "Layer 1",
      "weight": 0.4,
      "assets": [
        {
          "name": "Bitcoin",
          "symbol": "WBTC",
          "address": "0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6"
        },
        {
          "name": "Ethereum",
          "symbol": "WETH",
          "address": "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619"
        }
      ]
    },
    {
      "name": "DeFi",
      "weight": 0.2,
      "assets": [
        {
          "name": "Uniswap",
          "symbol": "UNI",
          "address": "0xb33EaAd8d922B1083446DC23f610c2567fB5180f"
        },
        {
          "name": "Aave",
          "symbol": "AAVE",
          "address": "0xD6DF932A45C0f255f85145f286eA0b292B21C90B"
        }
      ]
    },
    {
      "name": "Infrastructure",
      "weight": 0.2,
      "assets": [
        {
          "name": "ChainLink",
          "symbol": "LINK",
          "address": "0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39"
        },
        {
          "name": "Graph Token",
          "symbol": "GRT",
          "address": "0x5fe2B58c013d7601147DcdD68C143A77499f5531"
        }
      ]
    },
    {
      "name": "Stablecoins",
      "weight": 0.2,
      "assets": [
        {
          "name": "Circle USD",
          "symbol": "USDC",
          "address": "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359"
        },
        {
          "name": "Stasis EUR",
          "symbol": "EURS",
          "address": "0xE111178A87A3BFf0c8d18DECBa5798827539Ae99"
        }
      ]
    }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grid-bot-example"><a class="header" href="#grid-bot-example">Grid Bot Example</a></h1>
<p>The Grid Bot is a Rust-based automated trading bot that implements a grid trading strategy on EVM-compatible blockchains. Grid trading works by placing buy and sell orders at regular price intervals (grid levels) to capture profits from price fluctuations.</p>
<p>You can see the example code <a href="https://github.com/Cavenfish/bonanca/tree/main/examples/crates/grid-bot">here</a>.</p>
<h2 id="features-2"><a class="header" href="#features-2">Features</a></h2>
<ul>
<li>Automated grid trading on EVM chains</li>
<li>Configurable grid parameters (size, max orders, price delta)</li>
<li>Trading history and profit tracking</li>
<li>Real-time order management</li>
<li>Balance monitoring</li>
</ul>
<h3 id="building-the-project-1"><a class="header" href="#building-the-project-1">Building the Project</a></h3>
<pre><code class="language-bash">cd examples/crates/grid-bot
cargo build --release
</code></pre>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<p>This example project build a CLI which includes help docs that cover basic usage.</p>
<pre><code class="language-bash">grid-bot --help
</code></pre>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>Create a <code>grid_bot.json</code> configuration file with the following structure:</p>
<pre><code class="language-json">{
  "chain": "base",
  "rpc_url": "https://base.drpc.org",
  "keyvault": "./keyvault.json",
  "log_file": "./grid_bot_log.json",
  "child": 0,

  "trading_pair": {
    "token_a": {
      "name": "Circle USD",
      "symbol": "USDC",
      "address": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
      "decimals": 6
    },
    "token_b": {
      "name": "Ethereum",
      "symbol": "WETH",
      "address": "0x4200000000000000000000000000000000000006",
      "decimals": 18
    },
    "num_grids": 5,
    "upper_limit": 2300.0,
    "lower_limit": 1700.0,
    "buy_amount": 0.1,
    "sell_amount": 0.1
  }
}
</code></pre>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<ul>
<li><strong>num_grids</strong>: Number of grid levels to place</li>
<li><strong>upper_limit</strong>: The highest price at which to place sell orders</li>
<li><strong>lower_limit</strong>: The lowest price at which to place buy orders</li>
<li><strong>buy_amount</strong>: The amount of token_a to use for each buy level</li>
<li><strong>sell_amount</strong>: The amount of token_b to sell at each sell level</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scalper-bot-example"><a class="header" href="#scalper-bot-example">Scalper Bot Example</a></h1>
<p>The Scalper Bot is a Python-based trading bot. Scalping involves making many small trades to capture tiny price differences (spreads). This uses the CoW
protocol for limit orders.</p>
<p>You can check out the code <a href="https://github.com/Cavenfish/bonanca/blob/main/examples/python/scalper.py">here</a>.</p>
<h2 id="features-3"><a class="header" href="#features-3">Features</a></h2>
<ul>
<li>Automated scalping on EVM-compatible blockchains</li>
<li>Configurable trade parameters and limits</li>
<li>Detailed trade logging and performance tracking</li>
<li>Order history tracking (buy/sell averages)</li>
<li>Profit monitoring and reporting</li>
<li>Support for any EVM token pair</li>
</ul>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>Create a <code>scalper.toml</code> configuration file:</p>
<pre><code class="language-toml">chain = "Polygon"
rpc_url = "https://polygon-rpc.com"
keyvault = "./keyvault.json"
child = 0
log_file = "./grid_bot_log.json"

[base]
name = "Wrapped Ether"
symbol = "WETH"
address = "0x7ceB23fD6bC0adD59E27f9EA9d0231e0f01cc726"
decimals = 18

[target]
name = "USDC Coin"
symbol = "USDC"
address = "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359"
decimals = 6

[trade_settings]
size = 0.1
max_orders = 5
delta = 0.2
profit = 1.5
expiry = "0-30-300"
</code></pre>
<h2 id="configuration-parameters"><a class="header" href="#configuration-parameters">Configuration Parameters</a></h2>
<h3 id="trade-settings"><a class="header" href="#trade-settings">Trade Settings</a></h3>
<ul>
<li><strong>size</strong>: The size of each scalp trade (in base token units)</li>
<li><strong>max_orders</strong>: Maximum number of concurrent orders</li>
<li><strong>delta</strong>: Price difference between placed buy orders (percentage)</li>
<li><strong>profit</strong>: Minimum profit target for sell orders (percentage)</li>
<li><strong>expiry</strong>: Order expiration time format "DAYS-HOURS-MINUTES"</li>
</ul>
<h2 id="output-files"><a class="header" href="#output-files">Output Files</a></h2>
<ul>
<li><strong>log_file</strong>: JSON file containing:
<ul>
<li>Active orders</li>
<li>Current profit</li>
<li>Buy history (total bought, average buy price)</li>
<li>Sell history (total sold, average sell price)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyvault"><a class="header" href="#keyvault">KeyVault</a></h1>
<p>Bonança stores the seed to your HD wallet in what is called a <code>KeyVault</code>,
which can be serialized into a <code>json</code> file. This takes inspiration from
<code>keystore</code> files, if you are unfamiliar with them consider reading
<a href="https://julien-maffre.medium.com/what-is-an-ethereum-keystore-file-86c8c5917b97">this post</a>.</p>
<p>When serialized, your HD wallet seed is encrypted using a password you
define. An example key vault <code>json</code> file structure is as follows:</p>
<pre><code class="language-json">{
  "vault": {
    "cipher": "aes256-gcm",
    "cipher_params": { "nonce": "287189f34a1433d2de201d08" },
    "cipher_text": "7a34170003c0a7b3ccb75bac28757801a7d9b5e1ff062afa4af5f3c03e7d8982eb1f36ccce87436e42b44ffea6bcf39eba8c15d4e79ee0bf012811fca81ae1e112c0f8ae5d8e43ac8cad1ae961b11207",
    "kdf": "pbkdf2",
    "kdf_params": {
      "key_length": 32,
      "n": 600000,
      "salt": "M6lWvNAGuZBSp9fBGAUEqw"
    },
    "mac": "$argon2id$v=19$m=19456,t=2,p=1$M6lWvNAGuZBSp9fBGAUEqw$/U5VYPmg3+BQj0ttOyPnOUjH7bP23V9/tgvBpovna/8",
    "salt": "M6lWvNAGuZBSp9fBGAUEqw"
  },
  "chain_keys": {
    "Solana": ["AbwHhAquPXvDfxvWEh1b4mG969DQF9wJQSK5k8XKSKtG"],
    "EVM": ["0x50940F0C5779BE15F7ACB12E9b75128e1415BFec"]
  }
}
</code></pre>
<p>Breaking down the components:</p>
<ul>
<li><code>cipher</code> is the encryption algorithm used to encrypt your HD wallet
seed</li>
<li>Within <code>cipher_params</code> you find <code>nonce</code> which is an initialization
vector for the AES-256-GCM algorithm</li>
<li><code>cipher_text</code> is your encrypted seed</li>
<li><code>kdf</code> is the key derivation function used (PBKDF2)</li>
<li><code>kdf_params</code> are the parameters used in the key derivation function
<ul>
<li><code>key_length</code> is the length in bytes of the key</li>
<li><code>n</code> is the number of cycles in the algorithm, where 600,000
is used to make encrypting/decrypting time consuming to
prevent brute force attacks</li>
<li><code>salt</code> is the password salt</li>
</ul>
</li>
<li><code>mac</code> is your hashed and salted password using Argon2 (its parameters
are included in the mac string)</li>
<li><code>salt</code> again the password salt</li>
<li><code>chain_keys</code> these are your public keys for various blockchains</li>
</ul>
<p>Changes to any of these fields can result in failure to decrypt the seed,
and possibly permanent loss of all funds.</p>
<p>The only point of weakness within the <code>KeyVault</code> encryption is your choice
of password. If a malicious actor were to get a hold of your <code>json</code> file,
they could try to decrypt it by either guessing the password or the seed.
Guessing the seed is extremely difficult and unlikely, whereas guessing
a password is more doable. This means picking a good password is crucial.</p>
<p><code>KeyVault</code> includes your public keys within the <code>chain_keys</code> field, which
allows you to view your accounts without having to decrypt your <code>KeyVault</code>.
There are positives and negatives to this approach, with the main benefit
being that you can check wallet balances without supplying your password.
The main drawback is that if a malicious actor were to get this file, they
would know how valuable breaking the encryption is.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-bonança"><a class="header" href="#contributing-to-bonança">Contributing to Bonança</a></h1>
<p>I welcome contributions from the community to help improve Bonança! Whether it's fixing bugs, adding new features, or improving documentation, your contributions are valuable to me. Here are some guidelines to help you get started:</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<ol>
<li><strong>Fork the Repository</strong>: Start by forking the Bonança repository on GitHub to create your own copy of the project.</li>
<li><strong>Create a Branch</strong>: Create a new branch for your feature or bug fix. Use a descriptive name for your branch, such as <code>add-new-bot</code> or <code>fix-index-calculation</code>.</li>
<li><strong>Make Changes</strong>: Make your changes in the new branch. Ensure that your code follows the existing coding style and conventions used in the project.</li>
<li><strong>Test Your Changes</strong>: Write tests for your changes to ensure they work as expected and do not introduce new issues. Run existing tests to verify that everything is still functioning correctly.</li>
<li><strong>Commit Your Changes</strong>: Commit your changes with clear and concise commit messages that describe the purpose of the changes.</li>
<li><strong>Push to Your Fork</strong>: Push your changes to your forked repository on GitHub.</li>
<li><strong>Create a Pull Request</strong>: Open a pull request from your branch to the main Bonança repository. Provide a detailed description of the changes you made and any relevant information for reviewers.</li>
</ol>
<h2 id="reporting-issues"><a class="header" href="#reporting-issues">Reporting Issues</a></h2>
<p>If you encounter any bugs or have suggestions for new features, please open an issue on the <a href="https://github.com/Cavenfish/bonanca/issues">GitHub Issues</a> page. Provide as much detail as possible to help us understand and address the issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="support-bonança"><a class="header" href="#support-bonança">Support Bonança</a></h1>
<p>If you find Bonança useful and would like to support its development, there are several ways you can contribute:</p>
<ol>
<li><strong>Star the Repository</strong>: Show your appreciation by starring the <a href="https://github.com/Cavenfish/bonanca">Bonança GitHub repository</a>. This helps increase the visibility of the project and encourages others to check it out.</li>
<li><strong>Report Issues</strong>: If you encounter any bugs or have suggestions for new features, please open an issue on the <a href="">GitHub Issues</a> page. Providing detailed information helps me address problems more effectively.</li>
<li><strong>Contribute Code</strong>: If you're a developer, consider contributing code to the project. You can fork the repository, make improvements or add new features, and submit a pull request.</li>
<li><strong>Spread the Word</strong>: Share Bonança with your friends, colleagues, and on social media. The more people who know about it, the more support and contributions the project can receive.</li>
</ol>
<p>Thank you for being a part of the Bonança community!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reporting-security-issues"><a class="header" href="#reporting-security-issues">Reporting Security Issues</a></h1>
<p>If you discover a security vulnerability in Bonança, please report it to me privately so that we can address the issue before it becomes public knowledge. This helps protect all users of Bonança and ensures that vulnerabilities are fixed promptly.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
